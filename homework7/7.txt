1. С какими интерфейсами мы уже сталкивались в предыдущих уроках?
Обратите внимание на уроки, в которых мы читали из стандартного ввода и писали в стандартный вывод.

Если я правильно понял вопрос, имеются в виду функции fmt.Scanln, fmt.Println и т.п.
На примере fmt.Println:
func Println(a ...interface{}) (n int, err error) {
	return Fprintln(os.Stdout, a...)
}

На вход принимает пустой интерфейсный тип interface{}, он не описывает требуемые методы, значит любой объект подходит.
Пустой интерфейс можно использовать, когда нужно обращаться и работать с непредсказуемыми или пользовательскими типами.
"Три точки" перед interface{} означает, что функцию можно вызвать с любым количеством аргументов.

Так же иногда использовали функцию panic
func panic(v interface{})

2. Посмотрите примеры кода в своём портфолио(домашках)
Везде ли ошибки обрабатываются грамотно? Хотите ли вы переписать какие-либо функции?

Мне кажется, если не учитывать первую домашку, то в моих домашках нет ни одного скрипта с грамотной обработкой ошибок (а где-то вообще отсутствует).

if b == 0 {
    fmt.Println("Делить на ноль нельзя!")
    os.Exit(1)
}
Например, вместо конструкции выше, наверное, надо было лучше сделать так:
if b == 0 {
    panic("Делить на ноль нельзя!")
}

Для отдельных вызываемых функций:
1) добавил бы проверки входных параметров;
2) возврат не только результата, но и ошибки:
Т.е. вместо этого:
func getFibonacci(n int) int {
уже применил бы данную конструкцию с добавлением проверки err != nil из функции,откуда вызывается данная функция:
func getFibonacci(n int) int, err {

3. Проверьте себя:
a. Вам должны быть знакомы следующие ключевые слова Go: interface.

в Go интерфейс - это перечисление методов с параметрами, привязанных к типу.
Компилятор проверяет, что тип данных  имеет все описанные в интерфейсе методы

b. Вам должны быть знакомы следующие функции: panic, recover.
panic - встроенная функция, выбрасывает исключение
recover - функция для перехвата исключений на любом уровнец (panic)